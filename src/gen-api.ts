/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/machines": {
    /** List your machines */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /machines */
          cursor?: string;
        };
      };
      responses: {
        /** @description Your machines */
        200: {
          content: {
            "application/json": {
              machines: ({
                slug: components["schemas"]["MachineSlug"];
                /** Format: date-time */
                createdAt: string;
                currentVersion?: components["schemas"]["MachineVersionInfo"];
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of machines.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /**
     * Create a new machine definition.
     * @description Note: No instances of a machine definition can be created until
     * you create a machine definition version for it.
     */
    post: {
      requestBody: components["requestBodies"]["CreateMachineDefinition"];
      responses: {
        /** @description The machine definition was created successfully. */
        201: never;
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}": {
    /**
     * Get a machine definition.
     * @description Retrieve the machine definition
     */
    get: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition. */
          machineSlug: components["schemas"]["MachineSlug"];
        };
      };
      responses: {
        /** @description The machine was retrieved successfully. */
        200: {
          content: {
            "application/json": {
              machine: {
                /** Format: date-time */
                createdAt: string;
                currentVersion?: components["schemas"]["MachineVersionInfo"];
              };
            };
          };
        };
        403: components["responses"]["Forbidden"];
      };
    };
    /**
     * Create a new machine instance.
     * @description Create a new instance of the machine definition with the given slug.
     *
     * The `allowWrite` function for the machine definition version will be called
     * to authorize the initial transition and, if it fails, a 403 with code
     * `rejected-by-machine-authorizer` will be returned.
     *
     * Otherwise, the state of the machine instance after the initial transition
     * will be returned.
     *
     * All top-level events have a 10 second timeout for the machine to settle.
     * Settling means that the machine has reached a stable state and has no
     * child services running.
     *
     * If the machine does not settle within 10 seconds but has completed at least
     * one transition successfully, a 200 with the current state will be returned,
     * the child services will be stopped, and error events will be delivered for
     * each stopped service before the next event is sent.
     *
     * If a machine instance for this (`machineSlug`, instance `slug`) already exists,
     * a 409 will be returned.
     */
    post: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition to create an instance of. */
          machineSlug: components["schemas"]["MachineSlug"];
        };
      };
      requestBody: components["requestBodies"]["CreateMachineInstance"];
      responses: {
        /** @description The machine instance was created successfully. */
        200: {
          content: {
            "application/json": components["schemas"]["State"];
          };
        };
        403: components["responses"]["Forbidden"];
        409: components["responses"]["Conflict"];
      };
    };
    /**
     * Delete a machine and any versions and migrations associated with it.
     * @description Delete a machine and any versions and migrations associated with it.
     *
     * *THIS IS OBVIOUSLY A DANGEROUS OPERATION AND WILL INTENTIONALLY CAUSE DATA LOSS*
     *
     * If any instances exist for the machine, a 409 error will be returned with an `invalid-state` code.
     * You can delete the instances and then retry the machine deletion.
     *
     * All versions associated with the machine and all migrations between those versions
     * will be deleted.
     *
     * There is no option to recover data after a machine is deleted.
     *
     * To prevent accidental deletion, we require two validation parameters:
     *   - hmacSha256OfMachineNameWithMachineNameKey - `base64urlEncode(hmacSha256(key = "machine name", "machine name"))`
     *   - dangerDataWillBeDeletedForever - true
     *
     * A 400 error with the `parameter` set to the name of the incorrect parameter will be returned
     * if the validation parameters are incorrect.
     *
     * This endpoint requires admin access.
     */
    delete: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition to delete. */
          machineSlug: components["schemas"]["MachineSlug"];
        };
      };
      requestBody: components["requestBodies"]["DeleteMachine"];
      responses: {
        /** @description The machine instance was deleted successfully. */
        204: never;
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
        409: components["responses"]["Conflict"];
      };
    };
  };
  "/machines/{machineSlug}/i": {
    /** List the instances of this machine */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /machines/{machineSlug}/i */
          cursor?: string;
        };
      };
      responses: {
        /** @description The instances of this machine */
        200: {
          content: {
            "application/json": {
              instances: ({
                slug: components["schemas"]["MachineInstanceSlug"];
                /** Format: date-time */
                createdAt: string;
                status: components["schemas"]["MachineInstanceStatus"];
                machineVersion: components["schemas"]["MachineVersionInfo"];
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of instances.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
  };
  "/machines/{machineSlug}/i/{instanceSlug}": {
    /**
     * Get the current state of a machine instance.
     * @description Retrieve the state of the machine instance that was previously created by
     * calling `POST /machines/{machineSlug}` and may have had events sent to it
     * by calling `POST /machines/{machineSlug}/i/{instanceSlug}/events`.
     *
     * The `allowRead` function for the machine definition version will be called
     * to authorize the read and, if it fails, a 403 with code
     * `rejected-by-machine-authorizer` will be returned.
     *
     * Otherwise, the current state of the machine instance will be returned.
     *
     * Obviously, the state returned may be out of date by the time it is returned
     * because reads are non-blocking but a the returned state will always be
     * self-consistent.
     */
    get: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The slug/name for the machine instance. */
          instanceSlug: components["schemas"]["MachineInstanceSlug"];
        };
      };
      responses: {
        /** @description The state was retrieved successfully. */
        200: {
          content: {
            "application/json": components["schemas"]["State"];
          };
        };
        403: components["responses"]["Forbidden"];
      };
    };
    /**
     * Delete a machine instance and any transitions, state, or pending upgrades associated with it.
     * @description Delete a machine instance and any transitions, state, or pending upgrades associated with it.
     *
     * *THIS IS OBVIOUSLY A DANGEROUS OPERATION AND WILL INTENTIONALLY CAUSE DATA LOSS*
     *
     * All historical transitions associated with the machine and all current state and context
     * will be deleted.
     *
     * There is no option to recover data after an instance is deleted.
     *
     * To prevent accidental deletion, we require two validation parameters:
     *   - hmacSha256OfMachineInstanceNameWithMachineNameKey - `base64urlEncode(hmacSha256(key = "machine name", "machine instance name"))`
     *   - dangerDataWillBeDeletedForever - true
     *
     * A 400 error with the `parameter` set to the name of the incorrect parameter will be returned
     * if the validation parameters are incorrect.
     *
     * This endpoint requires admin access.
     */
    delete: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition to delete. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The slug/name for the machine instance. */
          instanceSlug: components["schemas"]["MachineInstanceSlug"];
        };
      };
      requestBody: components["requestBodies"]["DeleteMachineInstance"];
      responses: {
        /** @description The machine instance was deleted successfully. */
        204: never;
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}/i/{instanceSlug}/admin": {
    /**
     * Get the administrative state of an instance
     * @description Retrieve the state of the machine instance that was previously created by
     * calling `POST /machines/{machineSlug}` and may have had events sent to it
     * by calling `POST /machines/{machineSlug}/i/{instanceSlug}/events`.
     *
     * No machine authorizers will be called to authorize this read so this requires
     * instances.read scope.
     *
     * The full context for the instance (instead of only public context) will be returned.
     */
    get: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The slug/name for the machine instance. */
          instanceSlug: components["schemas"]["MachineInstanceSlug"];
        };
      };
      responses: {
        /** @description The instance was retrieved successfully. */
        200: {
          content: {
            "application/json":
              components["schemas"]["AdministrativeInstanceState"];
          };
        };
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}/i/{instanceSlug}/events": {
    /** List the transitions for this machine instance */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /machines/{machineSlug}/i/{instanceSlug}/events */
          cursor?: string;
        };
      };
      responses: {
        /** @description The transitions for this machine instance */
        200: {
          content: {
            "application/json": {
              transitions: ({
                /** Format: date-time */
                createdAt: string;
                state: components["schemas"]["StateValue"];
                event: components["schemas"]["Event"];
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of transitions.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /**
     * Send an event to a machine instance.
     * @description Send an event to the machine instance that was previously created by
     * calling `POST /machines/{machineSlug}`.
     *
     * The `allowWrite` function for the machine definition version will be called
     * to authorize the send and, if it fails, a 403 with code
     * `rejected-by-machine-authorizer` will be returned.
     *
     * Otherwise, the state of the machine instance after any transitions resulting
     * from the event will be returned.
     *
     * The request will wait for the machine to settle before returning a response.
     * Settling means that the machine has reached a stable state and has no
     * child services running.
     *
     * All top-level events have a 10 second timeout for the machine to settle.
     *
     * If the machine does not settle within 10 seconds but has completed at least
     * one transition successfully, a 200 with the current state will be returned,
     * the child services will be stopped, and error events will be delivered for
     * each stopped service before the next event is sent.
     */
    post: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The slug/name for the machine instance. */
          instanceSlug: components["schemas"]["MachineInstanceSlug"];
        };
      };
      requestBody: components["requestBodies"]["SendMachineInstanceEvent"];
      responses: {
        /** @description The event was delivered successfully. */
        200: {
          content: {
            "application/json": components["schemas"]["State"];
          };
        };
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}/i/{instanceSlug}/v": {
    /**
     * Update the desired machine version for an existing instance.
     * @description Set the desired machine version for an existing instance.
     *
     * The instance will not be upgraded immediately but will be upgraded
     * the next time an event is sent to it from a settled state.
     *
     * A 400 with code "no-migration-path" will be returned if there is
     * no path through the set of existing migrations from the current
     * instance version to the desired instance version.
     */
    put: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The slug/name for the machine instance. */
          instanceSlug: components["schemas"]["MachineInstanceSlug"];
        };
      };
      requestBody:
        components["requestBodies"]["UpdateDesiredMachineInstanceVersion"];
      responses: {
        /**
         * @description The desired version was recorded successfully and will be applied
         * the next time an event is sent to the instance from a settled state.
         */
        201: never;
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}/i/{instanceSlug}/status": {
    /**
     * Update the status of a machine instance
     * @description Set the status of the machine.
     *
     * Machines in the 'paused' status will reject any events sent to them
     * with a 409 error with a code of "invalid-state".
     *
     * 'running' instances will accept events normally.
     *
     * It is **dangerous** to set an instance's status to 'paused'!
     * You will drop events and, because delayed events are only retried
     * 5 times (with ~30 seconds between each try), some delayed events
     * may be dropped and **never** sent to your machine.
     *
     * This exists **purely** to stop a runaway machine instance that is
     * stuck in a loop of creating too many events.
     *
     * This endpoint requires admin access.
     */
    put: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The slug/name for the machine instance. */
          instanceSlug: components["schemas"]["MachineInstanceSlug"];
        };
      };
      requestBody: components["requestBodies"]["UpdateMachineInstanceStatus"];
      responses: {
        /** @description The instance status was set. */
        204: never;
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
        409: components["responses"]["Conflict"];
      };
    };
  };
  "/machines/{machineSlug}/v": {
    /** List the machine versions for this machine */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /machines/{machineSlug}/v */
          cursor?: string;
        };
      };
      responses: {
        /** @description The machine versions for this machine */
        200: {
          content: {
            "application/json": {
              versions: (components["schemas"]["MachineVersionInfo"])[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of machine versions.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /**
     * Provisionally create a new machine definition version.
     * @description This operation returns a code upload URL and fields that can be used
     * to upload the code for the machine definition version.
     *
     * Once the code is uploaded, call `PUT /machines/:machineSlug/v/:machineDefinitionVersionId`
     * with the `machineDefinitionVersionId` returned from this operation to
     * finalize the creation of the machine definition version.
     */
    post: {
      parameters: {
        query?: {
          /** @description Will the code be uploaded gzipped? */
          gzip?: boolean;
        };
        path: {
          /** @description The slug/name for the machine definition this version is related to. */
          machineSlug: components["schemas"]["MachineSlug"];
        };
      };
      requestBody: components["requestBodies"][
        "ProvisionallyCreateMachineDefinitionVersion"
      ];
      responses: {
        /**
         * @description The machine definition version was provisionally created successfully.
         *
         * Now, post the code for the machine definition version as follows:
         *
         * ```
         * const { codeUploadFields, codeUploadUrl } = await provisionalVersionCreationResponse.json();
         * const uploadForm = new FormData();
         * for (const [key, value] of Object.entries(codeUploadFields)) {
         *   uploadForm.append(key, value as string);
         * }
         * uploadForm.set("content-type", "application/javascript");
         * uploadForm.append(
         *   "file",
         *   new Blob(["javascript-code-here"], {
         *     type: "application/javascript",
         *   }),
         *   "your-file-name.js",
         * );
         * const uploadRes = await fetch(
         *   codeUploadUrl,
         *   {
         *     method: "POST",
         *     body: uploadForm,
         *   },
         * );
         * ```
         *
         * And then finalize the creation of the machine definition version by
         * calling `PUT /machines/:machineSlug/v/:machineDefinitionVersionId` with
         * the `machineDefinitionVersionId` returned from this operation.
         */
        200: {
          content: {
            "application/json": {
              machineVersionId: components["schemas"]["SignedMachineVersionId"];
              /** @description The URL to upload the machine definition version code to. */
              codeUploadUrl: string;
              /** @description The fields that must be included as form data in the upload request. */
              codeUploadFields: {
                [key: string]: string | undefined;
              };
            };
          };
        };
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}/v/{signedMachineVersionId}": {
    /**
     * Finalize creation of a machine definition version.
     * @description After retrieving the `machineDefinitionVersionId` and code upload
     * instructions from `POST /machines/:machineSlug/v`, and after
     * uploading the code as described, call this operation to finalize
     * the creation of the machine definition version.
     *
     * After this operation, you can create instances of the machine
     * definition with  this version.
     */
    put: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition this version is related to. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The signed machine version id returned from `POST /machines/:machineSlug/v`. */
          signedMachineVersionId:
            components["schemas"]["SignedMachineVersionId"];
        };
      };
      requestBody:
        components["requestBodies"]["CreateMachineDefinitionVersion"];
      responses: {
        /** @description The version was created. */
        200: {
          content: {
            "application/json": {
              machineVersionId: components["schemas"]["MachineVersionId"];
            };
          };
        };
      };
    };
  };
  "/machines/{machineSlug}/migrations": {
    /**
     * Provisionally create a new machine version migration.
     * @description This operation returns a code upload URL and fields that can be used
     * to upload the code for the machine version migration.
     *
     * Once the code is uploaded, call `PUT /machines/:machineSlug/migrations/:machineVersionMigrationId`
     * with the `machineVersionMigrationId` returned from this operation to
     * finalize the creation of the machine version migration.
     */
    post: {
      parameters: {
        query?: {
          /** @description Will the code be uploaded gzipped? */
          gzip?: boolean;
        };
        path: {
          /** @description The slug/name for the machine definition this version is related to. */
          machineSlug: components["schemas"]["MachineSlug"];
        };
      };
      requestBody: components["requestBodies"][
        "ProvisionallyCreateMachineVersionMigration"
      ];
      responses: {
        /**
         * @description The machine version migration was provisionally created successfully.
         *
         * Now, post the code for the machine version migration as follows:
         *
         * ```
         * const { codeUploadFields, codeUploadUrl } = await provisionalVersionMigrationCreationResponse.json();
         * const uploadForm = new FormData();
         * for (const [key, value] of Object.entries(codeUploadFields)) {
         *   uploadForm.append(key, value as string);
         * }
         * uploadForm.set("content-type", "application/javascript");
         * uploadForm.append(
         *   "file",
         *   new Blob(["javascript-code-here"], {
         *     type: "application/javascript",
         *   }),
         *   "your-file-name.js",
         * );
         * const uploadRes = await fetch(
         *   codeUploadUrl,
         *   {
         *     method: "POST",
         *     body: uploadForm,
         *   },
         * );
         * ```
         *
         * And then finalize the creation of the machine version migration by
         * calling `PUT /machines/:machineSlug/migrations/:machineVersionMigrationId` with
         * the `machineVersionMigrationId` returned from this operation.
         */
        200: {
          content: {
            "application/json": {
              machineVersionMigrationId:
                components["schemas"]["SignedMachineVersionMigrationId"];
              /** @description The URL to upload the machine definition version code to. */
              codeUploadUrl: string;
              /** @description The fields that must be included as form data in the upload request. */
              codeUploadFields: {
                [key: string]: string | undefined;
              };
            };
          };
        };
        400: components["responses"]["BadRequest"];
        403: components["responses"]["Forbidden"];
      };
    };
  };
  "/machines/{machineSlug}/migrations/{signedMachineVersionMigrationId}": {
    /**
     * Finalize creation of a machine version migration.
     * @description After retrieving the `machineVersionMigrationId` and code upload
     * instructions from `POST /machines/:machineSlug/migrations`, and after
     * uploading the code as described, call this operation to finalize
     * the creation of the machine version migration.
     *
     * After this operation, you can upgrade existing machine instances
     * using this migration.
     */
    put: {
      parameters: {
        path: {
          /** @description The slug/name for the machine definition this version is related to. */
          machineSlug: components["schemas"]["MachineSlug"];
          /** @description The signed machine version id returned from `POST /machines/:machineSlug/v`. */
          signedMachineVersionMigrationId:
            components["schemas"]["SignedMachineVersionMigrationId"];
        };
      };
      requestBody: components["requestBodies"]["CreateMachineVersionMigration"];
      responses: {
        /** @description The version was created. */
        200: {
          content: {
            "application/json": {
              machineVersionId?:
                components["schemas"]["MachineVersionMigrationId"];
            };
          };
        };
      };
    };
  };
  "/logs": {
    /**
     * Retrieve logs for a time range.
     * @description Retrieve logs starting at the `from` time, optionally
     * filtered by `to`, `machine`, `instance`, and `version`.
     *
     * You will receive at most 100 log entries (each consisting
     * of potentially multiple lines) but you may receive fewer
     * entries due to various partitioning schemes.
     *
     * You may retry the call by specifying the returned `maxTimestamp`
     * as the new `from` time to retrieve additional logs.
     */
    get: {
      parameters: {
        query: {
          /** @description The ISO-8601 timestamp of the earilest-timestamped log to retrieve */
          from: components["schemas"]["Timestamp"];
          /** @description The ISO-8601 timestamp of the latest-timestamped log to retrieve */
          to?: components["schemas"]["Timestamp"];
          /** @description The name of the machine to retrieve logs for */
          machine?: components["schemas"]["MachineSlug"];
          /** @description The name of the machine instance to retrieve logs for */
          instance?: components["schemas"]["MachineInstanceSlug"];
          /** @description The id of the machine version to retrieve logs for */
          version?: components["schemas"]["MachineVersionId"];
        };
      };
      responses: {
        /** @description The requested logs. */
        200: {
          content: {
            "application/json": {
              maxTimestamp: components["schemas"]["Timestamp"];
              logs: ({
                timestamp: components["schemas"]["Timestamp"];
                /** @description The ID of the organization that owns the machines that produced this log. */
                orgId: string;
                machineName: components["schemas"]["MachineSlug"];
                instanceName: components["schemas"]["MachineInstanceSlug"];
                machineVersionId: components["schemas"]["MachineVersionId"];
                /** @enum {string} */
                outputType: "stdout" | "stderr";
                /** @description Raw log output */
                log: string;
              })[];
            };
          };
        };
      };
    };
  };
  "/rt": {
    /**
     * Subscribe to real-time updates of machine instances.
     * @description This is a websocket endpoint.
     * Connect and send WSToServerMsg messages and receive WSToClientMsg messages.
     */
    get: {
      parameters: {
        query: {
          /** @description JWT signed with your State Backed key. Same as the token typically passed in the authorization header. */
          token: string;
        };
      };
    };
  };
  "/idps": {
    /** List the identity providers configured for your org */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /idps */
          cursor?: string;
        };
      };
      responses: {
        /** @description The trusted identity providers for your organization */
        200: {
          content: {
            "application/json": {
              idps: ({
                iss?: string;
                aud?: string;
                algs: (components["schemas"]["SigningAlgorithm"])[];
                jwksUrl?: string;
                mapping: {
                  [key: string]: unknown;
                };
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of identity providers.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /**
     * Upsert an identity provider
     * @description Token exchange involves exchanging an identity provider-signed token for a
     * State Backed-signed token. By adding an identity provider configuration to
     * State Backed, you are instructing State Backed to trust any valid token
     * from that identity provider when evaluating whether to allow a token exchange.
     * You are also extracting the claims from that token that you want to make available
     * to your token providers to include in the State Backed token.
     *
     * For example, if you are using Auth0 as your identity provider, you can configure
     * State Backed to trust your Auth0 tokens by calling:
     *
     * ```bash
     * curl -XPOST https://statebacked.dev/idps \
     *   -H 'authorization: Bearer sbsk_...'
     *   --data '{
     *     "aud": "https://<your-auth0-domain>.us.auth0.com/api/v2/",
     *     "iss": "https://<your-auth0-domain>.us.auth0.com/",
     *     "jwksUrl": "https://<your-auth0-domain>.us.auth0.com/.well-known/jwks.json",
     *     "algs": ["RS256"],
     *     "mapping": {
     *       "sub.$": "$.sub",
     *       "email.$": "$.email",
     *       "provider": "auth0",
     *     }
     *   }'
     * ```
     *
     * State Backed uses the audience (`aud`) and issuer (`iss`) claims in any tokens
     * provided for exchange to identify the identity provider to use for verification.
     *
     * In this example, token providers would be have access to `sub`, `email`, and `provider`
     * claims that they could include in the resultant State Backed token.
     *
     * Upserts may change algorithms, mappings, keys or jwksUrls.
     *
     * This endpoint requires admin access.
     */
    post: {
      requestBody: components["requestBodies"]["UpsertIdentityProvider"];
      responses: {
        /** @description The identity provider was created or updated. */
        204: never;
      };
    };
    /**
     * Delete an identity provider
     * @description Delete the identity provider and immediately reject any token exchange
     * requests that provide tokens signed by the idp.
     */
    delete: {
      requestBody: components["requestBodies"]["DeleteIdentityProvider"];
      responses: {
        /** @description The identity provider was deleted. */
        204: never;
      };
    };
  };
  "/token-providers": {
    /** List the token providers configured for your org */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /token-providers */
          cursor?: string;
        };
      };
      responses: {
        /** @description The token providers for your organization */
        200: {
          content: {
            "application/json": {
              tokenProviders: ({
                service: string;
                keyId: components["schemas"]["KeyId"];
                mapping: {
                  [key: string]: unknown;
                };
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of token providers.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /**
     * Upsert a token provider
     * @description Token exchange involves exchanging an identity provider-signed token for a
     * State Backed-signed token.
     *
     * Token providers are responsible for creating State Backed tokens from a standardized
     * claim set extracted from identity provider tokens by their mappings.
     *
     * Token providers are identified by a service name.
     * You might, for instance, want a service name for each application that you host
     * with State Backed.
     *
     * Token providers also specify the State Backed key to use to sign the tokens they
     * generate and a mapping that creates the claims for the generated token.
     *
     * For example, if your identity provider mappings extract claims like this:
     *
     * ```
     * {
     *   "sub": "your-sub",
     *   "email": "your-email",
     *   "provider": "identity-provider"
     * }
     * ```
     *
     * you could create a token provider like this:
     *
     * ```bash
     * curl -XPOST https://statebacked.dev/token-providers \
     *   -H 'authorization: Bearer sbsk_...'
     *   --data '{
     *     "keyId": "sbk_...", // ID for a previously-created State Backed key
     *     "service": "your-app", // any identifier for your token provider
     *     "mapping": {
     *       "sub.$": "$.sub",
     *       "email.$": "$.email",
     *       "provider.$": "$.provider",
     *     }
     *   }'
     * ```
     *
     * That token provider would allow you to exchange any of your identity provider-
     * signed tokens for a State Backed token that includes the sub, email, and provider
     * claims, all of which would be available for your use in `allowRead` and `allowWrite`
     * functions in your machine definitions.
     *
     * Upserts may change key ids and mappings.
     *
     * This endpoint requires admin access.
     */
    post: {
      requestBody: components["requestBodies"]["UpsertTokenProvider"];
      responses: {
        /** @description The token provider was created or updated. */
        204: never;
      };
    };
  };
  "/token-providers/{service}": {
    /**
     * Delete a token provider
     * @description Delete the token provider and immediately reject any token exchange
     * requests that request tokens using the token provider's service.
     */
    delete: {
      parameters: {
        path: {
          /** @description The service identifier for the token provider to delete */
          service: string;
        };
      };
      responses: {
        /** @description The token provider was deleted. */
        204: never;
      };
    };
  };
  "/tokens": {
    /**
     * Exchange an identity provider-signed token for a State Backed token
     * @description Once you have configured at least one identity provider (by posting to /idps)
     * and at least one token provider (by posting to /token-providers), you can exchange
     * any identity provider token for a token generated by one of your token providers.
     *
     * This allows you to have completely secure, end-to-end authorization with your
     * State Backed machine instances without any server-side code while using your
     * identity provider of choice.
     *
     * This endpoint should generally conform to https://datatracker.ietf.org/doc/html/rfc8693
     */
    post: {
      requestBody: components["requestBodies"]["ExchangeToken"];
      responses: {
        /** @description Your State Backed token */
        200: {
          content: {
            "application/json": {
              /** @description Your State Backed access token. */
              access_token: string;
              /** @constant */
              issued_token_type:
                "urn:ietf:params:oauth:token-type:access_token";
              /** @constant */
              token_type: "Bearer";
            };
          };
        };
      };
    };
  };
  "/orgs": {
    /** List your organizations */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /orgs */
          cursor?: string;
        };
      };
      responses: {
        /** @description Your organizations */
        200: {
          content: {
            "application/json": {
              orgs: ({
                id: components["schemas"]["OrgId"];
                name: string;
                role: components["schemas"]["OrgMemberRole"];
                /** Format: date-time */
                createdAt: string;
                limits: {
                  monthlyEventsLimit: number;
                  monthlyReadsLimit: number;
                };
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of organizations.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /** @description Create an org */
    post: {
      requestBody: components["requestBodies"]["CreateOrg"];
      responses: {
        /** @description New org */
        200: {
          content: {
            "application/json": {
              id: components["schemas"]["OrgId"];
            };
          };
        };
      };
    };
  };
  "/keys": {
    /** List your keys */
    get: {
      parameters: {
        query?: {
          /** @description A cursor returned from a previous call to /keys */
          cursor?: string;
        };
      };
      responses: {
        /** @description Your keys */
        200: {
          content: {
            "application/json": {
              keys: ({
                id: components["schemas"]["KeyId"];
                name: string;
                scopes: (unknown)[];
                /** Format: date-time */
                createdAt: string;
              })[];
              /**
               * @description The cursor to use on the next call to retrieve the next page of keys.
               * If no cursor is returned, there are no more pages to retrieve.
               */
              cursor?: string;
            };
          };
        };
      };
    };
    /** @description Create a key */
    post: {
      requestBody: components["requestBodies"]["CreateKey"];
      responses: {
        /** @description New key */
        200: {
          content: {
            "application/json": {
              id: components["schemas"]["KeyId"];
              key: string;
            };
          };
        };
      };
    };
  };
  "/keys/{keyId}": {
    /** @description Delete a key */
    delete: {
      parameters: {
        path: {
          /** @description The key ID to delete */
          keyId: components["schemas"]["KeyId"];
        };
      };
      responses: {
        /** @description The key was deleted */
        204: never;
      };
    };
  };
  "/billing": {
    /** Retrieve the link to your organization's billing portal */
    get: {
      responses: {
        /** @description The link to your billing portal */
        200: {
          content: {
            "application/json": {
              /** @description The link to your billing portal */
              url: string;
            };
          };
        };
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * @description An identifier for the machine definition. Must be unique within your organization.
     * @example my-machine
     */
    MachineSlug: string;
    /** @description The signed machine definition version ID. */
    SignedMachineVersionId: string;
    /** @description The signed machine version migration ID. */
    SignedMachineVersionMigrationId: string;
    /** @description The ID of a machine definition version. */
    MachineVersionId: string;
    /** @description The ID of a machine version migration. */
    MachineVersionMigrationId: string;
    /**
     * @description An identifier for the machine instance. Must be unique within the instances for the associated machine definition.
     * @example user-1234
     */
    MachineInstanceSlug: string;
    /**
     * @description The status of a machine instance.
     * @enum {string}
     */
    MachineInstanceStatus: "running" | "paused";
    /**
     * @description The state of the machine instance.
     *
     * For a machine instance with in a single, top-level state, this will be a string.
     * For a machine instance in a hierarchically-nested state, it will be an object
     * mapping parent states to child states.
     * For a machine instance in a parallel state, it will be an object with multiple
     * keys.
     */
    StateValue:
      | components["schemas"]["SimpleStateValue"]
      | components["schemas"]["CompoundStateValue"];
    /** @description A simple state */
    SimpleStateValue: string;
    /** @description A compound state */
    CompoundStateValue: {
      [key: string]: components["schemas"]["StateValue"] | undefined;
    };
    /** @description The full state of a machine instance. */
    AdministrativeInstanceState: {
      state: components["schemas"]["StateValue"];
      /** @description The full context of the machine instance. */
      context: {
        [key: string]: unknown;
      };
      status: components["schemas"]["MachineInstanceStatus"];
      /** @description Array of tags for the current states */
      tags: (string)[];
      /** @description Is the state machine complete */
      done: boolean;
      machineVersion: components["schemas"]["MachineVersionInfo"];
      desiredMachineVersion?: components["schemas"]["MachineVersionInfo"];
      /** Format: date-time */
      createdAt: string;
    };
    /** @description The state of a machine instance. */
    State: {
      state: components["schemas"]["StateValue"];
      /**
       * @description The public context of the machine instance.
       *
       * This includes all context under the `public` key.
       */
      publicContext?: {
        [key: string]: unknown;
      };
      /** @description Array of tags for the current states */
      tags: (string)[];
      /** @description Is the state machine complete */
      done: boolean;
    };
    /** @description An event to send to a machine instance. */
    Event:
      | components["schemas"]["EventWithPayload"]
      | components["schemas"]["EventWithoutPayload"];
    /**
     * @description An event to send to a machine instance with a payload.
     *
     * Event types and payloads are user-defined for a given machine definition.
     */
    EventWithPayload: {
      /** @description The type of the event. */
      type: string;
      [key: string]: unknown;
    };
    /**
     * @description An event to send to a machine.
     *
     * Event types are user-defined for a given machine definition.
     */
    EventWithoutPayload: string;
    /**
     * Format: date-time
     * @description A timestamp
     */
    Timestamp: string;
    /**
     * @description Websocket message sent to the client when an instance has been updated.
     * Clients will receive instance update messages after subscribing to an instance.
     */
    WSToClientInstanceUpdateMsg: {
      /** @constant */
      type: "instance-update";
      machineName: components["schemas"]["MachineSlug"];
      machineInstanceName: components["schemas"]["MachineInstanceSlug"];
      publicContext: {
        [key: string]: unknown;
      };
      state: components["schemas"]["StateValue"];
      /** @description Array of tags for the current states */
      tags: (string)[];
      /** @description Is the state machine complete */
      done: boolean;
    };
    /**
     * @description Websocket message sent to the client to indicate that an error has occurred
     * in processing a previously-sent message, identified by `requestId`.
     */
    WSToClientErrorMsg: {
      /** @constant */
      type: "error";
      /** @description Request ID that caused the error. */
      requestId: string;
      /** @description HTTP status code corresponding to the error. */
      status: number;
      /** @description Error code */
      code?: string;
    };
    /** @description Websocket messages that may be sent to the client */
    WSToClientMsg:
      | components["schemas"]["WSToClientInstanceUpdateMsg"]
      | components["schemas"]["WSToClientErrorMsg"];
    /** @description Websocket message sent to the server to subscribe to a machine instance */
    WSToServerSubscribeToInstanceMsg: {
      /** @constant */
      type: "subscribe-to-instance";
      /** @description ID for this request. Must be unique per connection. Used to associate errors with the request. */
      requestId: string;
      machineName: components["schemas"]["MachineSlug"];
      machineInstanceName: components["schemas"]["MachineInstanceSlug"];
    };
    /** @description Websocket message sent to the server to unsubscribe from a machine instance */
    WSToServerUnsubscribeFromInstanceMsg: {
      /** @constant */
      type: "unsubscribe-from-instance";
      /** @description ID for this request. Must be unique per connection. Used to associate errors with the request. */
      requestId: string;
      machineName: components["schemas"]["MachineSlug"];
      machineInstanceName: components["schemas"]["MachineInstanceSlug"];
    };
    /**
     * @description Websocket message sent to the server to keep the connection and subscriptions alive.
     * Must be sent at least every 5 minutes or the connection and subscriptions will be canceled
     * and will need to be reestablished.
     */
    WSToServerPingMsg: {
      /** @constant */
      type: "ping";
    };
    /** @description Websocket messages that may be sent to the server. */
    WSToServerMsg:
      | components["schemas"]["WSToServerSubscribeToInstanceMsg"]
      | components["schemas"]["WSToServerUnsubscribeFromInstanceMsg"]
      | components["schemas"]["WSToServerPingMsg"];
    /**
     * @description An identifier for an organization
     * @example org_uHvZHpF4STWvMg8BKVCUTg
     */
    OrgId: string;
    /**
     * @description The role that a member has in an organization
     * @enum {string}
     */
    OrgMemberRole: "admin" | "read" | "write";
    /**
     * @description An identifier for a key
     * @example sbk_nXzdtCxESemgtxS5JX-LrA
     */
    KeyId: string;
    /**
     * @description An authorization scope associated with a key.
     * Any request that is signed by a JWT with this key will have access to the scopes associated with that key.
     *
     * @enum {string}
     */
    KeyScope:
      | "events.write"
      | "events.read"
      | "state.read"
      | "instances.read"
      | "instances.write"
      | "instances.admin"
      | "machines.read"
      | "machines.write"
      | "machines.admin"
      | "machine-versions.read"
      | "machine-versions.write"
      | "analytics.read"
      | "org.read"
      | "org.write"
      | "org.keys.write"
      | "org-members.write"
      | "logs.read"
      | "tokens.admin";
    /** @enum {string} */
    SigningAlgorithm:
      | "HS256"
      | "HS384"
      | "HS512"
      | "PS256"
      | "PS384"
      | "PS512"
      | "RS256"
      | "RS384"
      | "RS512"
      | "ES256"
      | "ES384"
      | "ES512"
      | "EdDSA";
    MachineVersionInfo: {
      id: components["schemas"]["MachineVersionId"];
      /** Format: date-time */
      createdAt: string;
      clientInfo: string;
    };
  };
  responses: {
    /** @description The request was malformed. */
    BadRequest: {
      content: {
        "application/json": {
          /** @description A description of the error. */
          error?: string;
          /**
           * @description A code specifying the type of error.
           *
           * - `specify-org` indicates that the user has access to multiple orgs and the operation requires specifying an organization. Pass the `x-statebacked-org-id` header to specify an org ID.
           * - `invalid-parameter` indicates that one of the provided parameters was incorrect
           *
           * @enum {string}
           */
          code?: "specify-org" | "invalid-parameter";
          /** @description The name of the invalid parameter */
          parameter?: string;
        };
      };
    };
    /** @description The request was unauthorized. */
    Forbidden: {
      content: {
        "application/json": {
          /** @description A description of the error. */
          error?: string;
          /**
           * @description A code specifying the type of error.
           * @enum {string}
           */
          code?:
            | "missing-scope"
            | "rejected-by-machine-authorizer"
            | "missing-user"
            | "missing-org";
        };
      };
    };
    /** @description The resource already exists. */
    Conflict: {
      content: {
        "application/json": {
          /**
           * @description Machine-readable identifier for the type of error
           * @enum {string}
           */
          code?: "invalid-state";
          /** @description Human-readable identifier for the error */
          error?: string;
        };
      };
    };
  };
  parameters: never;
  requestBodies: {
    /** @description Request to create a machine definition. */
    CreateMachineDefinition?: {
      content: {
        "application/json": {
          slug: components["schemas"]["MachineSlug"];
        };
      };
    };
    /** @description Request to provisionally create a machine definition version. */
    ProvisionallyCreateMachineDefinitionVersion?: {
      content: {
        "application/json": Record<string, never>;
      };
    };
    /** @description Finalize creation of a machine definition version. */
    CreateMachineDefinitionVersion?: {
      content: {
        "application/json": {
          /**
           * @description Informational only. Any string that describes this version.
           * Good uses would be a semantic version number or git commit.
           */
          clientInfo?: string;
          /**
           * @description Whether to make this version the current version for the machine definition.
           * If `true`, the current version will be set to this version.
           * If `false`, the current version will not be changed.
           */
          makeCurrent?: boolean;
        };
      };
    };
    /** @description Request to provisionally create a machine version migration. */
    ProvisionallyCreateMachineVersionMigration?: {
      content: {
        "application/json": {
          fromMachineVersionId: components["schemas"]["MachineVersionId"];
          toMachineVersionId: components["schemas"]["MachineVersionId"];
        };
      };
    };
    /** @description Finalize creation of a machine version migration. */
    CreateMachineVersionMigration?: {
      content: {
        "application/json": Record<string, never>;
      };
    };
    /**
     * @description Request to create an instance of a machine.
     *
     * If machineVersionId is provided, creates an instance of the machine
     * definition version with that ID. Otherwise, creates an instance of the
     * current version of the machine definition.
     */
    CreateMachineInstance?: {
      content: {
        "application/json": {
          slug: components["schemas"]["MachineInstanceSlug"];
          /**
           * @description The initial context for the machine instance.
           * Defaults to `{}`.
           */
          context?: {
            [key: string]: unknown;
          };
          machineVersionId?: components["schemas"]["MachineVersionId"];
        };
      };
    };
    /** @description Request to send an event to an instance of a machine. */
    SendMachineInstanceEvent?: {
      content: {
        "application/json": {
          event: components["schemas"]["Event"];
        };
      };
    };
    /** @description Request to update the machine version for an existing instance. */
    UpdateDesiredMachineInstanceVersion?: {
      content: {
        "application/json": {
          targetMachineVersionId: components["schemas"]["MachineVersionId"];
        };
      };
    };
    /** @description Request to update the status of an existing instance. */
    UpdateMachineInstanceStatus?: {
      content: {
        "application/json": {
          status: components["schemas"]["MachineInstanceStatus"];
        };
      };
    };
    /** @description Validation parameters to prove that you really do want to delete the machine. */
    DeleteMachine?: {
      content: {
        "application/json": {
          /**
           * @description Just to ensure that you understand the ramifications of this action.
           * @constant
           */
          dangerDataWillBeDeletedForever: true;
          /**
           * @description This parameter serves to verify that you have read the documentation prior to
           * deleting a machine and have taken the time to consider whether you really want to do so.
           *
           * Provide `base64urlEncode(hmacSha256(key = "machine name", "machine name"))`
           */
          hmacSha256OfMachineNameWithMachineNameKey: string;
        };
      };
    };
    /** @description Validation parameters to prove that you really do want to delete the instance. */
    DeleteMachineInstance?: {
      content: {
        "application/json": {
          /**
           * @description Just to ensure that you understand the ramifications of this action.
           * @constant
           */
          dangerDataWillBeDeletedForever: true;
          /**
           * @description This parameter serves to verify that you have read the documentation prior to
           * deleting a machine and have taken the time to consider whether you really want to do so.
           *
           * Provide `base64urlEncode(hmacSha256(key = "machine name", "machine instance name"))`
           */
          hmacSha256OfMachineInstanceNameWithMachineNameKey: string;
        };
      };
    };
    /** @description Identity provider configuration */
    UpsertIdentityProvider?: {
      content: {
        "application/json": {
          /** @description base64url-encoded key to use to verify token signatures (one of key or jwksUrl must be provided) */
          key?: string;
          /** @description Absolute URL at which to find a JWKS key set to verify token signatures (one of key or jwksUrl must be provided) */
          jwksUrl?: string;
          /** @description The audience claim that identifies tokens from this identity provider (one of aud or iss must be provided) */
          aud?: string;
          /** @description The issuer claim that identifies tokens from this identity provider (one of aud or iss must be provided) */
          iss?: string;
          /** @description Allowed signing algorithms */
          algs: (components["schemas"]["SigningAlgorithm"])[];
          /**
           * @description A mapping object that extracts claims from the identity provider tokens that token providers
           * can reference when creating the claims for State Backed tokens.
           *
           * The values of properties that end in ".$" are treated as JSONPath references into the
           * claim set of the provided token.
           *
           * So a mapping of `{ "sub.$": "$.sub" }` with identity provider claims of `{ "sub": "user-123" }`
           * will result in `{ "sub": "user-123" }` as the input claims into any token provider.
           */
          mapping: {
            [key: string]: unknown;
          };
        };
      };
    };
    /** @description Identity provider to delete */
    DeleteIdentityProvider?: {
      content: {
        "application/json": {
          /** @description Audience for the identity provider (at least one of aud or iss must be provided). */
          aud?: string;
          /** @description Issuer for the identity provider (at least one of aud or iss must be provided). */
          iss?: string;
        };
      };
    };
    /** @description Token provider configuration */
    UpsertTokenProvider?: {
      content: {
        "application/json": {
          /**
           * @description ID of the State Backed key (created using smply keys create or posting to /keys)
           * to use to sign  tokens created by this token provider.
           */
          keyId: string;
          /** @description The name of this token provider. This name is used to request tokens from the /tokens endpoint */
          service: string;
          /**
           * @description A mapping object that creates the claim set for the State Backed token and may reference
           * the claims extracted by the identity provider mappings.
           *
           * The values of properties that end in ".$" are treated as JSONPath references into the
           * claim set of the provided token.
           *
           * So a mapping of `{ "sub.$": "$.sub" }` with identity provider claims of `{ "sub": "user-123" }`
           * will result in `{ "sub": "user-123" }` as the State Backed token claims.
           */
          mapping: {
            [key: string]: unknown;
          };
        };
      };
    };
    /** @description Exchange an identity provider-signed token for a State Backed token. */
    ExchangeToken?: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description The type of grant being requested
           * @constant
           */
          grant_type: "urn:ietf:params:oauth:grant-type:token-exchange";
          /**
           * @description Identifies the token provider service to use to generate the token.
           *
           * Must be of the form: `https://tokens.statebacked.dev/<your-org-id>/<token-provider-service-id>`
           *
           * Where `your-org-id` can be found via `smply orgs list` and `token-provider-service-id`
           * is the `service` that you passed in your post to /token-providers.
           *
           * @example https://tokens.statebacked.dev/org_yourorg/your-service
           */
          audience: string;
          /**
           * @description The type of token being requested
           * @constant
           */
          "requested_token-type"?:
            "urn:ietf:params:oauth:token-type:access_token";
          /** @description A JWT signed by one of your configured identity providers (based on configurations posted to /idps) */
          subject_token: string;
        };
      };
    };
    /** @description Create a key */
    CreateKey?: {
      content: {
        "application/json": {
          name: string;
          /**
           * @description The scopes that any request with a token signed by this key will have access to.
           * You must either pass `scopes` or `use`.
           */
          scopes?: (components["schemas"]["KeyScope"])[];
          /**
           * @description The intended use for this key. This is a shorthand way to set a reasonable set of scopes.
           * You must either pass `scopes` or `use`.
           *
           * @enum {string}
           */
          use?: "production" | "ci";
        };
      };
    };
    /** @description Create an org */
    CreateOrg?: {
      content: {
        "application/json": {
          name: string;
          /**
           * @description If true, a key, trusted identity provider, and token provider
           * that support anonymous access will be created for the org.
           * The usual authorization checks still apply at the machine level
           * so individual reads and writes for anonymous access depends on
           * your `allowRead` and `allowWrite` implementations.
           * Auth context for anonymous tokens includes Session ID (`sid`),
           * Device ID (`did`), and `{ "auth": "anonymous" }`.
           *
           * @default true
           */
          allowAnonymousAccess?: boolean;
        };
      };
    };
  };
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
